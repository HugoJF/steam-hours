<?php

namespace App\Console\Commands;

use App\PlaytimeRequest;
use App\User;
use Carbon\Carbon;
use Illuminate\Console\Command;

class QueuePlaytime extends Command
{
	/**
	 * The name and signature of the console command.
	 *
	 * @var string
	 */
	protected $signature = 'playtime:queue {--F|force}';

	/**
	 * The console command description.
	 *
	 * @var string
	 */
	protected $description = 'Queues playtime update requests';

	/**
	 * Create a new command instance.
	 *
	 * @return void
	 */
	public function __construct()
	{
		parent::__construct();
	}

	public function info($string, $verbosity = null)
	{
		parent::info('[INFO] - ' . $string, $verbosity); // TODO: Change the autogenerated stub
	}

	public function warn($string, $verbosity = null)
	{
		parent::warn('[WARN] - ' . $string, $verbosity); // TODO: Change the autogenerated stub
	}

	/**
	 * Execute the console command.
	 *
	 * @return mixed
	 */
	public function handle()
	{
		$users = User::with(['playtimeRequests' => function ($q) {
			$q->latest()->limit(1);
		}])->get();


		foreach ($users as $user) {
			$preference = $user->request_preference ?? 0;
			$correctionLimit = $user->request_correction_limit ?? 1;

			$request = $user->playtimeRequests->first();

			if ($request->created_at->isFuture()) {
				$this->warn('Skipping user since request is already created in the future? maybe this is development...');

				continue;
			}

			$diffHours = $request->created_at->diffInHours();

			$this->info('Last request was at: ' . $request->created_at);

			$this->info('User resolution: ' . $user->playtime_expiration);
			$this->info('Last request expired by ' . $diffHours . ' hours');
			$this->info('Last request relative expiration: ' . ($diffHours / $user->playtime_expiration * 100) . '%');

			$ahead = ($request->created_at->hour - $preference) % $user->playtime_expiration;

			while ($ahead > 6) {
				$ahead -= 12;
			}

			while ($ahead < -6) {
				$ahead += 12;
			}

			if ($ahead > 0) {
				$this->info('Requests are ' . $ahead . 'h ahead of preference');
			} else {
				$this->info('Requests are ' . -$ahead . 'h behind of preference');
			}


			if (abs($ahead) > $correctionLimit) {
				$factor = $ahead / abs($ahead);
				$ahead = $correctionLimit * $factor;
			}

			$this->info('Limited difference to ' . $ahead . ' since CorrectionLimit is set to: ' . $correctionLimit);

			if ($ahead > 0) {
				$correctedDiff = $request->created_at->subHours(abs($ahead))->diffInHours();
			} else {
				$correctedDiff = $request->created_at->addHours(abs($ahead))->diffInHours();
			}

			$this->info('Corrected diff: ' . $correctedDiff);

			if ($correctedDiff >= $user->playtime_expiration) {
				$this->info('Request is still expired after correction by ' . $correctedDiff . ' hours');

				$request = PlaytimeRequest::make();
				$request->user()->associate($user);
				$request->previous()->associate(PlaytimeRequest::orderBy('created_at', 'desc')->first());
				$request->save();

				$this->info('Created request for user ' . $user->name . ': ' . $request->id);
			}
		}
	}
}
